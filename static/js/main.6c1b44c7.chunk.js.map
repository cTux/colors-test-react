{"version":3,"sources":["components/StartScreen/StartScreen.js","utils/getRandom.js","utils/getRandomColors.js","utils/getRandomColor.js","utils/modifyColor.js","actions/newGame.js","actions/newGame.config.js","components/StartScreen/StartScreen.connect.js","components/Board/Board.js","actions/decrementTimer.js","actions/colorClick.js","components/Board/Board.connect.js","components/App/App.js","components/App/App.connect.js","reducers/main.default.js","actions/newRound.js","serviceWorker.js","index.js","reducers/main.js"],"names":["StartScreen","titleText","this","props","game","isStarted","isFinished","points","correct","accuracy","tg","className","onClick","startNewGame","Component","getRandom","maxValue","minValue","Math","random","getRandomColors","randomColorValue","colors","Array","fill","undefined","map","isCorrect","value","randomColorIndex","colorsNumber","randomColor","color","newColor","timesToChange","randomOffset","randomIndex","modifyColor","newGame","state","secondsLeft","total","wrong","StartScreenConnected","connect","dispatch","type","Board","interval","latestHover","startInterval","endInterval","setInterval","decrementTimer","clearInterval","index","colorClick","cell","key","style","backgroundColor","join","onMouseMove","handleHover","handleColorClick","endGameProperties","action","payload","ceil","BoardConnected","colorClickAction","App","AppConnected","defaultState","newRound","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","store","createStore","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.6c1b44c7.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport './StartScreen.css';\n\nexport class StartScreen extends Component {\n  render() {\n    if (this.props.game.isStarted) {\n      return;\n    }\n\n    let titleText;\n    if (this.props.game.isFinished) {\n      titleText = `Correct: ${this.props.points.correct}, Accuracy: ${this.props.points.accuracy}%, Points: ${this.props.points.tg}`;\n    } else {\n      titleText = `Find a different color!`;\n    }\n\n    return (\n      <div className={'app-start-screen'}>\n        <div className={'app-start-screen-title'}>{titleText}</div>\n        <div className={'app-start-screen-btn-container'}>\n          <button className={'app-start-game-btn'} onClick={this.props.startNewGame}>\n            Start\n          </button>\n        </div>\n      </div>\n    );\n  }\n}\n","/**\n * @param {Number} maxValue\n * @param {Number} minValue\n * @returns {Number}\n */\nexport const getRandom = (maxValue, minValue = 0) => {\n  return ((Math.random() * (maxValue - minValue + 1)) >> 0) + minValue;\n};\n","import { getRandom } from './getRandom';\nimport { getRandomColor } from './getRandomColor';\nimport { modifyColor } from './modifyColor';\n\nexport const getRandomColors = () => {\n  const randomColorValue = getRandomColor(),\n    colorsNumber = 16;\n\n  const colors = new Array(colorsNumber)\n    .fill(undefined)\n    .map(() => ({\n      isCorrect: false,\n      value: randomColorValue,\n    }));\n\n  const randomColorIndex = getRandom(colorsNumber - 1),\n    randomColor = colors[randomColorIndex];\n\n  colors[randomColorIndex] = modifyColor(randomColor);\n\n  return colors;\n};\n","import { getRandom } from './getRandom';\n\n/**\n * @returns {Array<Number>}\n */\nexport const getRandomColor = () => {\n  return [ getRandom(255), getRandom(255), getRandom(255) ];\n};\n","import { getRandom } from './getRandom';\n\nexport const modifyColor = (color) => {\n  const newColor = {\n    isCorrect: true,\n    value: [ ...color.value ],\n  };\n\n  let timesToChange = 25,\n    randomOffset = getRandom(1) === 1 ? 1 : -1;\n\n  while (timesToChange--) {\n    const randomIndex = getRandom(2);\n    newColor.value[randomIndex] += randomOffset;\n\n    if (newColor.value[randomIndex] < 0) {\n      newColor.value[randomIndex] = 0;\n    }\n\n    if (newColor.value[randomIndex] > 255) {\n      newColor.value[randomIndex] = 255;\n    }\n  }\n\n  return newColor;\n};\n","import { secondsLeft } from './newGame.config';\nimport { getRandomColors } from '../utils/getRandomColors';\n\n/**\n * @param {AppState} state\n * @returns {AppState}\n */\nexport const newGame = (state) => {\n  return {\n    game: {\n      ...state.game,\n      isStarted: true,\n      isFinished: false,\n      secondsLeft,\n      colors: getRandomColors(),\n    },\n    points: {\n      total: 0,\n      correct: 0,\n      wrong: 0,\n      accuracy: 0,\n      tg: 0,\n    },\n  };\n};\n\n/**\n * @returns {Object}\n */\nexport const newGameAction = () => ({\n  type: 'NEW_GAME',\n});\n","export const secondsLeft = 60;\n","import { connect } from 'react-redux';\nimport { StartScreen } from './StartScreen';\nimport { newGameAction } from '../../actions/newGame';\n\n/**\n * @param {AppState} state\n * @returns {AppProps}\n */\nconst mapStateToProps = state => ({\n  game: {\n    isStarted: state.game.isStarted,\n    isFinished: state.game.isFinished,\n  },\n  points: {\n    correct: state.points.correct,\n    accuracy: state.points.accuracy,\n    tg: state.points.tg,\n  },\n});\n\nconst mapDispatchToProps = dispatch => ({\n  startNewGame: () => dispatch(newGameAction()),\n});\n\nexport const StartScreenConnected =\n  connect(mapStateToProps, mapDispatchToProps)(StartScreen);\n","import React, { Component } from 'react';\nimport './Board.css';\n\nexport class Board extends Component {\n  constructor(props) {\n    super(props);\n\n    this.interval = -1;\n    this.latestHover = -1;\n  }\n\n  componentDidMount() {\n    this.startInterval();\n  }\n\n  componentWillUnmount() {\n    this.endInterval();\n  }\n\n  startInterval() {\n    this.interval = setInterval(() => this.props.decrementTimer(), 1000);\n  }\n\n  endInterval() {\n    clearInterval(this.interval);\n  }\n\n  /**\n   * @param {Number} index\n   */\n  handleHover(index) {\n    this.latestHover = index;\n  }\n\n  /**\n   * @param {Number} index\n   * @param {Boolean} isCorrect\n   */\n  handleColorClick(index, isCorrect) {\n    if (this.latestHover === index) {\n      this.props.colorClick(isCorrect);\n    }\n  }\n\n  render() {\n    return (\n      <div className={'app-board'}>\n        <div className={'app-board-timer'}>\n          {this.props.game.secondsLeft}\n        </div>\n        {this.props.game.colors.map((cell, index) => {\n          return (\n            <div\n              key={index}\n              className={'app-board-cell'}\n              style={{ backgroundColor: `rgb(${cell.value.join(', ')})` }}\n              onMouseMove={() => this.handleHover(index)}\n              onClick={() => this.handleColorClick(index, cell.isCorrect)}\n            >\n            </div>\n          );\n        })}\n      </div>\n    );\n  }\n}\n","/**\n * @param {AppState} state\n * @returns {AppState}\n */\nexport const decrementTimer = (state) => {\n  const secondsLeft = state.game.secondsLeft - 1,\n    endGameProperties = {};\n\n  if (!secondsLeft) {\n    endGameProperties.isStarted = false;\n    endGameProperties.isFinished = true;\n  }\n\n  return {\n    ...state,\n    game: {\n      ...state.game,\n      ...endGameProperties,\n      secondsLeft,\n    },\n  };\n};\n\n/**\n * @returns {Object}\n */\nexport const decrementTimerAction = () => ({\n  type: 'DECREMENT_TIMER',\n});\n","import { getRandomColors } from '../utils/getRandomColors';\n\n/**\n * @param {AppState} state\n * @param {Object} action\n * @returns {AppState}\n */\nexport const colorClick = (state, action) => {\n  const isCorrect = action.payload;\n\n  const total = state.points.total + 1,\n    correct = state.points.correct + (isCorrect ? 1 : 0),\n    wrong = state.points.wrong + (isCorrect ? 0 : 1),\n    accuracy = (correct / total * 100) >> 0,\n    tg = Math.ceil(correct * correct / total * 5);\n\n  return {\n    ...state,\n    points: {\n      total,\n      correct,\n      wrong,\n      accuracy,\n      tg,\n    },\n    game: {\n      ...state.game,\n      colors: getRandomColors(),\n    },\n  };\n};\n\n/**\n * @returns {Object}\n */\nexport const colorClickAction = isCorrect => ({\n  type: 'COLOR_CLICK',\n  payload: isCorrect,\n});\n","import { connect } from 'react-redux';\nimport { Board } from './Board';\nimport { decrementTimerAction } from '../../actions/decrementTimer';\nimport { colorClickAction } from '../../actions/colorClick';\n\n/**\n * @param {AppState} state\n * @returns {AppProps}\n */\nconst mapStateToProps = state => ({\n  game: {\n    secondsLeft: state.game.secondsLeft,\n    colors: state.game.colors,\n  },\n});\n\nconst mapDispatchToProps = dispatch => ({\n  decrementTimer: () => dispatch(decrementTimerAction()),\n  colorClick: isCorrect => dispatch(colorClickAction(isCorrect)),\n});\n\nexport const BoardConnected =\n  connect(mapStateToProps, mapDispatchToProps)(Board);\n","import React, { Component } from 'react';\nimport './App.css';\nimport { StartScreen } from '../StartScreen';\nimport { Board } from '../Board';\n\nexport class App extends Component {\n  render() {\n    return (\n      <div className={'app'}>\n        {this.props.game.isStarted ? <Board /> : <StartScreen />}\n      </div>\n    );\n  }\n}\n","import { connect } from 'react-redux';\nimport { App } from './App';\n\n/**\n * @param {AppState} state\n * @returns {AppProps}\n */\nconst mapStateToProps = state => ({\n  game: {\n    isStarted: state.game.isStarted,\n  }\n});\n\nconst mapDispatchToProps = dispatch => ({\n});\n\n\nexport const AppConnected =\n  connect(mapStateToProps, mapDispatchToProps)(App);\n","/**\n * @type {AppState}\n */\nexport const defaultState = {\n  game: {\n    isStarted: false,\n    isFinished: false,\n    secondsLeft: 0,\n    colors: [],\n  },\n\n  points: {\n    total: 0,\n    correct: 0,\n    wrong: 0,\n    accuracy: 0,\n    tg: 0,\n  },\n};\n","import { getRandomColors } from '../utils/getRandomColors';\n\n/**\n * @param {AppState} state\n * @returns {AppState}\n */\nexport const newRound = (state) => {\n  return {\n    ...state,\n    game: {\n      ...state.game,\n      colors: getRandomColors(),\n    },\n  };\n};\n\n/**\n * @returns {Object}\n */\nexport const newRoundAction = () => ({\n  type: 'NEW_ROUND',\n});\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './components/App';\nimport { Provider } from 'react-redux';\nimport { createStore } from 'redux';\nimport { mainReducer } from './reducers';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={createStore(mainReducer)}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import { defaultState } from './main.default';\nimport { newGame } from '../actions/newGame';\nimport { newRound } from '../actions/newRound';\nimport { decrementTimer } from '../actions/decrementTimer';\nimport { colorClick } from '../actions/colorClick';\n\n/**\n * @param {AppState} state\n * @param {Object} action\n * @returns {AppState}\n */\nexport const mainReducer = (state = defaultState, action) => {\n  switch (action.type) {\n\n    case 'NEW_GAME':\n      return newGame(state);\n\n    case 'NEW_ROUND':\n      return newRound(state);\n\n    case 'DECREMENT_TIMER':\n      return decrementTimer(state);\n\n    case 'COLOR_CLICK':\n      return colorClick(state, action);\n\n    default:\n      return state;\n  }\n};\n"],"sourceRoot":""}